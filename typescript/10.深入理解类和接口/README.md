<!--
 * @Descripttion: 
 * @version: 
 * @Author: WangQing
 * @email: 2749374330@qq.com
 * @Date: 2020-01-26 13:07:33
 * @LastEditors  : WangQing
 * @LastEditTime : 2020-02-01 17:20:48
 -->
# 深入理解类和接口

[toc]

## 面向对象概念

### 为什么ts中面向对象

1. ts为前端面向对象带来契机

js语言没有类型检查，如果使用面向对象的方式开发，会产生大量的接口，而大量的接口会导致调用复杂度剧增，这种复杂度必须通过严格的类型检查来避免，尽管可以通过文档或者记忆力，但是它们没有强约束力

ts带来了完整的类型系统，因此开发复杂程序时，无论接口数量有多少，都可以获得完整的类型检查，并且这种类型检查具有强约束力

2. 面向对象中有许多成熟的模式，能处理负载逻辑

在过去的很多年中，在大型应用或复杂领域，面向对象已经积累了很多的经验

nextjs: 相当于前端的java spring
typeorm: ORM框架，比如：mongoose，类似于C# EF

### 什么是面向对象

面向对象： Oriented（基于） Object（事物），简称OO

- 是一种编程思想，提出一切以对象为切入点思考问题

其他编程思想：面向过程、函数式编程

面向过程：以功能流程为思考切入点，不太适合大型项目

函数式编程：以数学运算为思考切入点

面向对象：以划分类为思考切入点

类：可以产生对象的模板

### 如何学习

1. ts中的OOP（面向对象编程，Oriented Object Programing）
2. 小游戏练习

理解 -> 想法 -> 实践 -> 理解 -> ...

## 类的继承

### 继承的作用

继承可以描述类与类的关系

> 坦克、玩家坦克、敌方坦克
> 玩家坦克是坦克、敌方坦克是坦克

如果A和B都是类，并且可以描述为A是B，则A和B形成继承关系

- B是父类，A是子类
- B派生A，A继承自B
- B是A的基类，A是B的派生类

如果A继承自B,则A中自动拥有B中的所有成员

<img src="http://yuml.me/diagram/nofunky/class/[Tank]^-[PlayerTank], [Tank]^-[EnemyTank]" >

### 成员的重写

重写（override）：子类中覆盖父类的成员

子类成员不能改变父类成员的类型

无论属性还是方法，子类都可以对父类的相应成员进行重写，但是重写时，需要保证类型的匹配

注意this关键字：在继承关系中，this的指向是动态——调用方法时，根据具体的调用者确定this指向

super关键字：在子类的方法中，使用super关键字读取父类的成员

### 类型匹配

鸭子辨型法

子类的对象，始终可以赋值给父类

面向对象中，里式替换原则

如果需要判断一个数据的具体子类类型，可以使用instanceof

### protected修饰符

readonly:只读修饰符

访问权限修饰符：private public protected

protected: 受保护的成员，只能在自身和子类中访问

### 单根性和传递性

单根性：每个类最多只能拥有一个父类

传递性：如果A是B的父类，B是C的父类，那么认为A是C的父类

<img src="http://yuml.me/diagram/nofunky/class/[Tank]^-[PlayerTank], [Tank]^-[EnemyTank], [EnemyTank]^-[BossTank]" >

## 抽象类

### 为什么需要抽象类

<img src="http://yuml.me/diagram/nofunky/class/[棋子]^-[soldier], [棋子]^-[pao], [棋子]^-[horse]" >

有时，某个类只表示一个抽象概念，主要用于提取子类共有的成员，而不能直接创建它的对象。该类可以作为抽象类

给类前面加上```abstract```，表示该类是一个抽象类，抽象类不能创建类

### 抽象成员

父类中，可能知道有些成员是必须存在的，但是不知道该成员的值或实现是什么，因此，需要有一种强约束，让继承该类的子类，必须要实现该成员

**抽象类中**，可以有抽象成员，这些抽象成员必须在子类中实现

### 设计模式 - 模板模式

设计模式：面对一些常见的功能场景，有一些固定的、经过多年实践的成熟的方法，这些方法被称之为设计模式

模板方法：有些方法，所有的子类实现的流程完全一致，只是流程中的某个步骤的具体实现方法不一致，可以将该方法提取到父类，在父类中完成整个流程的实现，遇到实现不一致的方法时，将该方法制作成抽象方法

## 静态成员

### 什么是静态成员

静态成员是指，附着在类上的成员（属于某个构造函数的成员）

使用static修饰的成员是静态成员

实例成员：对象成员，属于某个类的对象

静态成员：非实例成员，属于某个类

### 静态方法中的this

实例方法中this指向**当前对象**

而静态方法中this指向**当前类**

### 设计模式 - 单例模式

单例模式：某些类的对象，在系统中最多只能使用一个

## 再谈接口

接口用于约束类、对象、函数，是一个类型锲约

> 有一个马戏团，马戏团中有很多动物，包括：狮子、老虎、猴子、狗，这些动物都具有共同的特征：名字、年龄、种类名称，还包含一个共同的方法：打招呼，它们各自有各自的技能，技能是可以通过训练改变

> 马戏团中有以下常见的技能

> - 火圈表演：单火圈、多火圈
> - 平衡表演：独木桥、走钢丝
> - 智慧表演：算术题、跳舞

不使用接口的缺点

- 对能力（成员函数）没有强约束力
- 容易将类型和能力耦合在一起

系统中缺少对对能力的定义 -- 接口

面向对象领域中的接口的语义：表达了某个类是否拥有某种能力

某个类具有某种能力，其实，就是实现了某种接口

类型保护函数：通过调用该函数，会触发ts的类型保护

```ts
function hasFireShow(ani: object): ani is IFireShow{
    if((ani as unknown as IFireShow).singleFire && (ani as unknown as IFireShow).doubleFire){
        return true;
    }
    return false;
}

```


## 索引器

```对象[值]```，使用成员表达式

在ts中，默认情况下，不对索引器（成员表达式）做严格的类型检查

使用配置```noImplicitAny```开启对隐式any的检查

隐式any：ts根据实际情况推导出的any类型

在类中，索引器书写的位置应该是所有成员之前

ts中索引器的作用

- 在严格的类型检查中，可以实现为类动态的添加成员
- 可以实现动态的操作类成员

在js中，所有的成员本质上，都是字符串，如果使用数字作为成员名，会自动转换为字符串

在ts中，如果某个类中使用了两种类型的索引器，要求两种索引器的值必须匹配

## this指向问题

https://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/

### 在js中this指向的几种情况

明确：大部分情况，this指向取决于函数的调用方式

- 如果直接调用函数（全局调用），this指向全局对象或undefined（启用严格模式）
- 如果使用```对象.方法```调用，this指向对象本身
- 如果是dom事件处理函数，this指向事件处理函数

特殊情况：
- 箭头函数，this在函数声明明确指向，指向函数位置的this
- 使用bind、apply、call手动绑定this指向的对象

### ts中的this

配置noImplicitThis为true，表示不允许this隐式指向any

在ts中，允许在书写函数时，手动声明该函数中的this指向，将this作为函数的第一个参数，该参数只用于约束this，并不是真正的参数，也不会出现在编译结果中